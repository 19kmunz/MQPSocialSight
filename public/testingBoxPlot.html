<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">

    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v4.js"></script>
</head>
<body>

<h1>SocialSight</h1>
<p>My first paragraph.</p>
<!-- Create a div where the boxplots will live -->
<div id="boxplots" ></div>
<div id="compare" ></div>
<!-- Plugin for color scale -->
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

<!-- Tooltip style -->
<style>
    .tooltip {
        background-color: black;
        border: none;
        border-radius: 5px;
        padding: 15px;
        min-width: 400px;
        text-align: left;
        color: white;
    }
</style>
<script>
    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 30, bottom: 50, left: 70},
        width = 460 - margin.left - margin.right,
        height = 200 - margin.top - margin.bottom;

    // Select the boxplot containter
    const boxplots = d3.select("#boxplots")
    const compare = d3.select("#compare")

    // Read the data, compute summary statistics and display
    d3.csv("MQPResponsesA.csv", function(data) {
        // Format data to questionExportTag: [numeric answers, ...]
        let keys = Object.keys(data[0]);
        let cleanNumericData = cleanTheData(keys, data)
        // Get the question text from the full data
        var sumtext = Object.keys(cleanNumericData).map(key => {
            let questionTextFull = data[0][key]

            let indOfSeperator = questionTextFull.indexOf(" - ")
            let questionText = questionTextFull.substring(0, indOfSeperator)
            let media = questionTextFull.slice(indOfSeperator + 3)
            let questionTag = key.substring(0, key.indexOf("_"))
            return {
                'key': key,
                value: {
                    questionText: questionText, media: media, questionTag: questionTag
                }
            }
        })
        var sumtextobj = sumtext.reduce(
            (obj, item) => Object.assign(obj, { [item.key]: item.value }), {});

        // Compute summary statistics
        // NOTE: uses both cleanNumericData AND original data to get, respectively, numerics and te
        var sumstat = Object.keys(cleanNumericData).map(key => {
            // For each question
            // Get the question text from the full data
            let textInfo = sumtextobj[key]

            // Compute the boxplot summary statistics
            let q1 = d3.quantile(cleanNumericData[key],.25)
            let median = d3.quantile(cleanNumericData[key],.5)
            let q3 = d3.quantile(cleanNumericData[key],.75)
            let interQuantileRange = q3 - q1
            let min = d3.max([q1 - 1.5 * interQuantileRange, d3.min(cleanNumericData[key])])
            let max = d3.min([q3 + 1.5 * interQuantileRange, d3.max(cleanNumericData[key])])
            let minOutliers = cleanNumericData[key].filter( d => d < min)
            let maxOutliers = cleanNumericData[key].filter( d => d > max)
            let outliers = minOutliers.concat(maxOutliers)
            let total = cleanNumericData[key].length

            return {
                'key' : key,
                value: { questionText: textInfo.questionText, media: textInfo.media, questionTag: textInfo.questionTag, q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max, outliers: outliers, total: total, points: cleanNumericData[key] }
            }
        })

        // Create the html boxplots
        displayBoxplots(sumstat)
    })

    function cleanTheData(keys, data) {
        let  cleanData = {}
        keys.forEach(function(key) {
            if(key === "Q4")
                return;

            // clean the data
            cleanData[key] = data
                .map(d => { return d[key] })
                .slice(2) // Ignore text and import id
                .map(p => { return phraseToNumber(p) })
                .filter(n => { return n != null })
                .sort(d3.ascending)
        })
        return cleanData
    }

    function displayBoxplots(sumstat) {
        // From sumstat: key, questionText, min, max, q1, q3, median, outliers, total
        // Define positions
        var y = height / 2
        var yBandwidth = height / 4;
        var xText = d3.scalePoint()
            .domain(["SA", "A", "LA", "LD", "D", "SD", "NoAd"])
            .range([0, width])
        var x = d3.scaleLinear()
            .domain([1, 7])
            .range([0, width])

        // Make boxplot container, margin, and scale for each question
        displayContainersMargin(sumstat)

        // Show axis labels
        displayAxis(sumstat, xText)

        // Show title
        displayTitle(sumstat)

        // Show the range line
        displayRange(sumstat, x, y, yBandwidth)

        // Show the rectangle for the q1, q3 box
        displayBox(sumstat, x, y, yBandwidth)

        // Show the median line
        displayMedian(sumstat, x, y, yBandwidth)

        // Show the outliers
        displayOutliers(sumstat, x, y, yBandwidth)

        // Show the totals
        displayTotals(sumstat)
    }
    function displayContainersMargin(sumstat) {
        compare
            .selectAll("boxplot") // No boxplots
            .data(sumstat) // Link to boxplot data
            .enter() // Create empties linked with data
            .append("svg") // container svg
            .attr("id", function(d) { return d.key;})
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g") // margin
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")")
            .classed("margin", true)
    }
    function displayAxis(sumstat, scale){
        compare
            .selectAll(".margin")
            .data(sumstat)
            .append("g") // bottom axis
            .attr("transform", "translate(0," + height + ")")
            .classed("bottomAxis", true)
            .call(d3.axisBottom(scale).ticks(7)) // TODO: dynamically set the axis labels
            .select(".domain").remove()
    }
    function displayTitle(sumstat) {
        compare
            .selectAll(".margin")
            .data(sumstat)
            .append("text")
            .attr("x", 0)
            .attr("y", margin.top)
            .classed("title", true)
            .text(function (d) {
                return d.value.questionText
            })
            .call(wrap, width)
    }
    function displayRange(sumstat, xScale, y, yBandwidth) {
        compare
            .selectAll(".margin")
            .data(sumstat)
            .append("line")
            .attr("x1", function (d) {
                return xScale(d.value.min)
            })
            .attr("x2", function (d) {
                return xScale(d.value.max)
            })
            .attr("y1", y + yBandwidth / 2)
            .attr("y2", y + yBandwidth / 2)
            .attr("stroke", "black")
            .style("width", 40)
            .classed("range", true)
    }
    function displayBox(sumstat, xScale, y, yBandwidth) {
        compare
            .selectAll(".margin")
            .data(sumstat)
            .append("rect")
            .attr("x", function (d) {
                return xScale(d.value.q1)
            })
            .attr("width", function (d) {
                return (xScale(d.value.q3) - xScale(d.value.q1))
            })
            .attr("y", y)
            .attr("height", yBandwidth)
            .attr("stroke", "black")
            .style("fill", "#69b3a2")
            .style("opacity", 0.3)
            .classed("box", true)
    }
    function displayMedian(sumstat, xScale, y, yBandwidth) {
        compare
            .selectAll(".margin")
            .data(sumstat)
            .append("line")
            .attr("y1", y)
            .attr("y2", y + yBandwidth)
            .attr("x1", function (d) {
                return (xScale(d.value.median))
            })
            .attr("x2", function (d) {
                return (xScale(d.value.median))
            })
            .attr("stroke", "black")
            .style("width", 80)
            .classed("median", true)
    }
    function displayOutliers(sumstat, xScale, y, yBandwidth) {
        compare
            .selectAll(".margin")
            .data(sumstat)
            .append("g")
            .classed("outliers", true)
            .each(function (d) {
                d3.select(this).selectAll('circles')
                    .data(d.value.outliers)
                    .enter()
                    .append('circle')
                    .attr("cx", function (d) {
                        return xScale(d)
                    })
                    .attr("cy", y + yBandwidth / 2)
                    .attr("r", 3)
                    .attr("opacity", 0.2)
            })
    }
    function displayTotals(sumstat) {
        compare
            .selectAll(".margin")
            .data(sumstat)
            .append("text")
            .classed("total", true)
            .text(function(d) { return "# Responses: " + (d.value.total) })
            .attr("x", 0)
            .attr("y", height + 35)
    }

    // https://stackoverflow.com/questions/24784302/wrapping-text-in-d3?lq=1
    function wrap(text, width) {
        text.each(function () {
            var text = d3.select(this),
                words = text.text().split(/\s+/).reverse(),
                word,
                line = [],
                lineNumber = 0,
                lineHeight = 1.1, // ems
                x = text.attr("x"),
                y = text.attr("y"),
                dy = 0, //parseFloat(text.attr("dy")),
                tspan = text.text(null)
                    .append("tspan")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("dy", dy + "em");
            // While there are words to check
            while (word = words.pop()) {
                line.push(word);
                tspan.text(line.join(" "));
                // If this word creates overflow
                if (tspan.node().getComputedTextLength() > width) {
                    // Remove the overflow word
                    line.pop();
                    // Set the real text
                    tspan.text(line.join(" "));
                    // Compute the real text length and center
                    let length = tspan.node().getComputedTextLength()
                    tspan.attr("dx", (width - length)/2)
                    // Prepare the next tspan for the rest of the words
                    line = [word];
                    tspan = text.append("tspan")
                        .attr("x", x)
                        .attr("y", y)
                        .attr("dy", ++lineNumber * lineHeight + dy + "em")
                        .text(word);
                }
            }
            // Compute the real text length and center for leftover
            let length = tspan.node().getComputedTextLength()
            tspan.attr("dx", (width - length)/2)
        });
    }

    function phraseToNumber(phrase) {
        switch (phrase) {
            case "Strongly agree":
            case "Very Frequently":
            case "10 minutes or Less":
            case "Video":
                return 1;
            case "Agree":
            case "Frequently":
            case "About 30 minutes":
            case "Image":
                return 2;
            case "Slightly agree":
            case "Occasionally":
            case "About an hour":
            case "Text":
                return 3;
            case "Slightly disagree":
            case "Rarely":
            case "More than an hour or multiple hours":
            case "No Priority":
                return 4;
            case "Disagree":
            case "Very Rarely":
                return 5;
            case "Strongly disagree":
            case "Never":
                return 6;
            case "There are no advertisements":
                return 7;
            case "":
                return null;
            default:
                throw new Error("Phrase '" +phrase+"' not supported")
            /*
            Strongly disagree, Disagree, Slightly disagree, Slightly agree, Agree, Strongly agree
            Never, Very Rarely, Rarely, Occasionally, Frequently, Very Frequently
            There are no advertisements
            10 minutes or Less, About 30 minutes, About an hour, More than an hour or multiple hours
            Video, Image, Text, No Priority
             */
        }
    }
    function numberToMedia(number){
        switch(number){
            case 1:
                return "Twitter";
            case 2:
                return "Instagram";
            case 3:
                return "Reddit";
            case 4:
                return "Tumblr";
            case 5:
                return "Tik Tok";
            case 6:
                return "BeReal";
            case 7:
                return "YouTube";
            case 8:
                return "Snapchat";
            case 9:
                return "Facebook";
            case 10:
                return "4Chan";
            case 11:
                return "LinkedIn";
            case 12:
                return "Twitch";
            default:
                throw new Error("Media num '" +number+"' not supported")

        }
    }
    function questionToScale(question){
        switch (question){
            case "C1":
            case "C2":
            case "C3":
            case "C6":
            case "D1":
            case "D5":
            case "D6":
            case "D7":
            case "D8":
            case "A3":
            case "A4":
                return ["Very Frequently", "Frequently", "Occasionally", "Rarely", "Very Rarely", "Never" ]
            case "A2":
                return ["Strongly agree", "Agree", "Slightly agree", "Slightly disagree", "Disagree", "Strongly disagree", "There are no advertisements"]
            case "D3":
                return ["Video", "Image", "Text", "No Priority"]
            case "D2":
                return["10 minutes or Less", "About 30 minutes", "About an hour", "More than an hour or multiple hours"]
            default:
                return ["Strongly agree", "Agree", "Slightly agree", "Slightly disagree", "Disagree", "Strongly disagree"]
        }
    }
</script>
</body>
</html>
