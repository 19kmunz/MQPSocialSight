<!DOCTYPE html>
<html lang="eng">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"
         integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">


    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v4.js"></script>
    <title>boxplots</title>
</head>
<body>

<h1>SocialSight</h1>
<p id="media">My first paragraph.</p>
<!-- Create a div where the boxplots will live -->
<div id="summaryplot"></div>
<div id="boxplots" >
    <div id="C">
        <div class="summary"></div>
        <div class="content"></div>
    </div>
    <div id="S">
        <div class="summary"></div>
        <div class="content"></div>
    </div>
    <div id="D">
        <div class="summary"></div>
        <div class="content"></div>
    </div>
    <div id="A">
        <div class="summary"></div>
        <div class="content"></div>
    </div>
</div>
<script>
    const media = "Facebook"
    const p = d3.select("#media").text(media)
    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 30, bottom: 50, left: 70},
        width = 460 - margin.left - margin.right,
        height = 200 - margin.top - margin.bottom;

    // For current media
        // For each human tag
    let humanTags = ["C", "S", "D", "A"]
    const boxplots = d3.select("#boxplots")
    humanTags.forEach(function(human) {
        fetch('/questions?media='+media+'&human='+human, {
            method:'GET',
            headers:{
                "Content-Type": "application/json"
            }
        })
            .then( function(response) {
                return response.json()
            })
            .then( function(json) {
                let data = json.questions
                let overall = [computeOverallData(data)]

                //data.append(computeOverallData(data))
                // Select the boxplot containter
                const humanDiv = boxplots.select("#"+human)

                var topsumstat = computeSummaryStatistics(overall)
                displayBoxplots(topsumstat, humanDiv.select(".summary"))

                const contentsDiv = humanDiv.select(".content")
                // Compute summary statistics
                var sumstat = computeSummaryStatistics(data)
                // Create the html boxplots
                displayBoxplots(sumstat, contentsDiv)
            })
    })

    function computeOverallData(data) {
        let summary = {
            "_id" : data[0].human+"_Summary",
            "qTag" : data[0].human+"_Summary",
            "mediaText" : data[0].mediaText,
            "title": data[0].human +" Summary",
        }
        let points = []
        data.forEach(question => {
            points.push(question.points)
        })
        points = d3.merge(points).sort(d3.ascending)
        summary.points = points;
        summary.total = points.length;
        return summary;
    }
    function computeSummaryStatistics(data) {
        return data.map(question => {
            // For each question
            // Get the question text from the full data
            let questionText = question.title
            let media = question.mediaText
            let questionTag = question.qTag

            // Compute the boxplot summary statistics
            let q1 = d3.quantile(question.points, .25)
            let median = d3.quantile(question.points, .5)
            let q3 = d3.quantile(question.points, .75)
            let interQuantileRange = q3 - q1
            let min = d3.max([q1 - 1.5 * interQuantileRange, d3.min(question.points)])
            let max = d3.min([q3 + 1.5 * interQuantileRange, d3.max(question.points)])
            let minOutliers = question.points.filter(d => d < min)
            let maxOutliers = question.points.filter(d => d > max)
            let outliers = minOutliers.concat(maxOutliers)
            let total = question.points.length

            return {
                'key': question.qTag,
                value: {
                    questionText: questionText,
                    media: media,
                    questionTag: questionTag,
                    q1: q1,
                    median: median,
                    q3: q3,
                    interQuantileRange: interQuantileRange,
                    min: min,
                    max: max,
                    outliers: outliers,
                    total: total,
                    points: question.points
                }
            }
        });
    }
    function displayBoxplots(sumstat, boxplots) {
        console.log("Sumstat: ")
        console.log(sumstat)
        // From sumstat: key, questionText, min, max, q1, q3, median, outliers, total
        // Define positions
        var y = height / 2
        var yBandwidth = height / 4;
        var xText = d3.scalePoint()
            .domain(["SA", "A", "LA", "LD", "D", "SD", "NoAd"])
            .range([0, width])
        var x = d3.scaleLinear()
            .domain([1, 7])
            .range([0, width])

        // Make boxplot container, margin, and scale for each question
        displayContainersMargin(sumstat, boxplots)

        // Show axis labels
        displayAxis(sumstat, boxplots, xText)

        // Show title
        displayTitle(sumstat, boxplots)

        // Show the range line
        displayRange(sumstat, boxplots, x, y, yBandwidth)

        // Show the rectangle for the q1, q3 box
        displayBox(sumstat, boxplots, x, y, yBandwidth)

        // Show the median line
        displayMedian(sumstat, boxplots, x, y, yBandwidth)

        // Show the outliers
        displayOutliers(sumstat, boxplots, x, y, yBandwidth)

        // Show the totals
        displayTotals(sumstat, boxplots)
    }
    function displayContainersMargin(sumstat, boxplots) {
        boxplots
            .selectAll("boxplot") // No boxplots
            .data(sumstat) // Link to boxplot data
            .enter() // Create empties linked with data
            .append("svg") // container svg
            .attr("id", function(d) { return d.key;})
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g") // margin
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")")
            .classed("margin", true)
    }
    function displayAxis(sumstat, boxplots, scale){
        boxplots
            .selectAll(".margin")
            .data(sumstat)
            .append("g") // bottom axis
            .attr("transform", "translate(0," + height + ")")
            .classed("bottomAxis", true)
            .call(d3.axisBottom(scale).ticks(7)) // TODO: dynamically set the axis labels
            .select(".domain").remove()
    }
    function displayTitle(sumstat, boxplots) {
        boxplots
            .selectAll(".margin")
            .data(sumstat)
            .append("text")
            .attr("x", 0)
            .attr("y", margin.top)
            .classed("title", true)
            .text(function (d) {
                return d.value.questionText + ((d.value.media) ? " - " + d.value.media : "")
            })
            .call(wrap, width)
    }
    function displayRange(sumstat, boxplots, xScale, y, yBandwidth) {
        boxplots
            .selectAll(".margin")
            .data(sumstat)
            .append("line")
            .attr("x1", function (d) {
                return xScale(d.value.min)
            })
            .attr("x2", function (d) {
                return xScale(d.value.max)
            })
            .attr("y1", y + yBandwidth / 2)
            .attr("y2", y + yBandwidth / 2)
            .attr("stroke", "black")
            .style("width", 40)
            .classed("range", true)
    }
    function displayBox(sumstat, boxplots, xScale, y, yBandwidth) {
        boxplots
            .selectAll(".margin")
            .data(sumstat)
            .append("rect")
            .attr("x", function (d) {
                return xScale(d.value.q1)
            })
            .attr("width", function (d) {
                return (xScale(d.value.q3) - xScale(d.value.q1))
            })
            .attr("y", y)
            .attr("height", yBandwidth)
            .attr("stroke", "black")
            .style("fill", "#69b3a2")
            .style("opacity", 0.3)
            .classed("box", true)
    }
    function displayMedian(sumstat, boxplots, xScale, y, yBandwidth) {
        boxplots
            .selectAll(".margin")
            .data(sumstat)
            .append("line")
            .attr("y1", y)
            .attr("y2", y + yBandwidth)
            .attr("x1", function (d) {
                return (xScale(d.value.median))
            })
            .attr("x2", function (d) {
                return (xScale(d.value.median))
            })
            .attr("stroke", "black")
            .style("width", 80)
            .classed("median", true)
    }
    function displayOutliers(sumstat, boxplots, xScale, y, yBandwidth) {
        boxplots
            .selectAll(".margin")
            .data(sumstat)
            .append("g")
            .classed("outliers", true)
            .each(function (d) {
                d3.select(this).selectAll('circles')
                    .data(d.value.outliers)
                    .enter()
                    .append('circle')
                    .attr("cx", function (d) {
                        return xScale(d)
                    })
                    .attr("cy", y + yBandwidth / 2)
                    .attr("r", 3)
                    .attr("opacity", 0.2)
            })
    }
    function displayTotals(sumstat, boxplots) {
        boxplots
            .selectAll(".margin")
            .data(sumstat)
            .append("text")
            .classed("total", true)
            .text(function(d) { return "# Responses: " + (d.value.total) })
            .attr("x", 0)
            .attr("y", height + 35)
    }

    // https://stackoverflow.com/questions/24784302/wrapping-text-in-d3?lq=1
    function wrap(text, width) {
        text.each(function () {
            var text = d3.select(this),
                words = text.text().split(/\s+/).reverse(),
                word,
                line = [],
                lineNumber = 0,
                lineHeight = 1.1, // ems
                x = text.attr("x"),
                y = text.attr("y"),
                dy = 0, //parseFloat(text.attr("dy")),
                tspan = text.text(null)
                    .append("tspan")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("dy", dy + "em");
            // While there are words to check
            while (word = words.pop()) {
                line.push(word);
                tspan.text(line.join(" "));
                // If this word creates overflow
                if (tspan.node().getComputedTextLength() > width) {
                    // Remove the overflow word
                    line.pop();
                    // Set the real text
                    tspan.text(line.join(" "));
                    // Compute the real text length and center
                    let length = tspan.node().getComputedTextLength()
                    tspan.attr("dx", (width - length)/2)
                    // Prepare the next tspan for the rest of the words
                    line = [word];
                    tspan = text.append("tspan")
                        .attr("x", x)
                        .attr("y", y)
                        .attr("dy", ++lineNumber * lineHeight + dy + "em")
                        .text(word);
                }
            }
            // Compute the real text length and center for leftover
            let length = tspan.node().getComputedTextLength()
            tspan.attr("dx", (width - length)/2)
        });
    }

    function phraseToNumber(phrase) {
        switch (phrase) {
            case "Strongly agree":
            case "Very Frequently":
            case "10 minutes or Less":
            case "Video":
                return 1;
            case "Agree":
            case "Frequently":
            case "About 30 minutes":
            case "Image":
                return 2;
            case "Slightly agree":
            case "Occasionally":
            case "About an hour":
            case "Text":
                return 3;
            case "Slightly disagree":
            case "Rarely":
            case "More than an hour or multiple hours":
            case "No priority":
                return 4;
            case "Disagree":
            case "Very Rarely":
                return 5;
            case "Strongly disagree":
            case "Never":
                return 6;
            case "There are no advertisements":
                return 7;
            case "":
                return null;
            default:
                throw new Error("Phrase '" +phrase+"' not supported")
            /*
            Strongly disagree, Disagree, Slightly disagree, Slightly agree, Agree, Strongly agree
            Never, Very Rarely, Rarely, Occasionally, Frequently, Very Frequently
            There are no advertisements
            10 minutes or Less, About 30 minutes, About an hour, More than an hour or multiple hours
            Video, Image, Text, No Priority
             */
        }
    }
    function numberToMedia(number){
        switch(number){
            case 1:
                return "Twitter";
            case 2:
                return "Instagram";
            case 3:
                return "Reddit";
            case 4:
                return "Tumblr";
            case 5:
                return "Tik Tok";
            case 6:
                return "BeReal";
            case 7:
                return "YouTube";
            case 8:
                return "Snapchat";
            case 9:
                return "Facebook";
            case 10:
                return "4Chan";
            case 11:
                return "LinkedIn";
            case 12:
                return "Twitch";
            default:
                throw new Error("Media num '" +number+"' not supported")

        }
    }
    function mediaToNumber(media){

        switch(media) {
            case "Twitter":
                return 1;
            case "Instagram":
                return 2;
            case "Reddit":
                return 3;
            case "Tumblr":
                return 4;
            case "Tik Tok":
                return 5;
            case "BeReal":
                return 6;
            case "YouTube":
                return 7;
            case "Snapchat":
                return 8;
            case "Facebook":
                return 9;
            case "4Chan":
                return 10;
            case "LinkedIn":
                return 11;
            case "Twitch":
                return 12;
            default:
                throw new Error("Media '" +media+"' not supported")
        }
    }
    function questionToScale(question){
        switch (question){
            case "C1":
            case "C2":
            case "C3":
            case "C6":
            case "D1":
            case "D5":
            case "D6":
            case "D7":
            case "D8":
            case "A3":
            case "A4":
                return ["Very Frequently", "Frequently", "Occasionally", "Rarely", "Very Rarely", "Never" ]
            case "A2":
                return ["Strongly agree", "Agree", "Slightly agree", "Slightly disagree", "Disagree", "Strongly disagree", "There are no advertisements"]
            case "D3":
                return ["Video", "Image", "Text", "No Priority"]
            case "D2":
                return["10 minutes or Less", "About 30 minutes", "About an hour", "More than an hour or multiple hours"]
            default:
                return ["Strongly agree", "Agree", "Slightly agree", "Slightly disagree", "Disagree", "Strongly disagree"]
        }
    }
</script>
</body>
</html>
