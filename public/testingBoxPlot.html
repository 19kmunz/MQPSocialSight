<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">

    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v4.js"></script>
</head>
<body>

<h1>SocialSight</h1>
<p>My first paragraph.</p>
<!-- Create a div where the boxplots will live -->
<div id="summaryplot"></div>
<div id="boxplots" ></div>
<script>
    const media = "Facebook"
    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 30, bottom: 50, left: 70},
        width = 460 - margin.left - margin.right,
        height = 200 - margin.top - margin.bottom;

    // Select the boxplot containter

    // SINGLE SUMMARY
    d3.csv("MQPResponsesA.csv", function(dataA) {
        d3.csv("MQPResponsesC.csv", function(dataC){
            d3.csv("MQPResponsesD.csv", function(dataD){
                d3.csv("MQPResponsesS.csv", function(dataS){
                    // Select the boxplot container
                    const boxplots = d3.select("#summaryplot").style("outline", "5px dotted green")

                    // Format data to questionExportTag: [numeric answers, ...]
                    let bigData = {}
                    let keys = ["A", "C", "D", "S"]
                    let datas = { "A": dataA, "C": dataC, "D": dataD, "S": dataS }
                    keys.forEach(function(key){
                        let keysX = Object.keys(datas[key][0]);
                        let cleanNumericDataX = cleanTheData(keysX, datas[key], mediaToNumber(media))
                        console.log(cleanNumericDataX)

                        // Filter by media
                        bigData[key] = d3.merge(Object.values(cleanNumericDataX)).sort(d3.ascending)
                    })
                    console.log("Big Data:")
                    console.log(bigData)
                    // Compute summary statistics
                    var sumstat = Object.keys(bigData).map(key => {
                        // For each question
                        // Compute the boxplot summary statistics
                        let q1 = d3.quantile(bigData[key],.25)
                        let median = d3.quantile(bigData[key],.5)
                        let q3 = d3.quantile(bigData[key],.75)
                        let interQuantileRange = q3 - q1
                        let min = d3.max([q1 - 1.5 * interQuantileRange, d3.min(bigData[key])])
                        let max = d3.min([q3 + 1.5 * interQuantileRange, d3.max(bigData[key])])
                        let minOutliers = bigData[key].filter( d => d < min)
                        let maxOutliers = bigData[key].filter( d => d > max)
                        let outliers = minOutliers.concat(maxOutliers)
                        let total = bigData[key].length

                        return {
                            'key' : key,
                            value: { questionText: key, q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max, outliers: outliers, total: total, points: bigData[key] }
                        }
                    })
                    console.log("Sumstat:")
                    console.log(sumstat)

                    // Create the html boxplots
                    displayBoxplots(sumstat, boxplots)
                })
            })
        })
    })

    // For all questions
    /*
    d3.csv("MQPResponsesA.csv", function(data) {
        // Select the boxplot containter
        const boxplots = d3.select("#boxplots")

        // Format data to questionExportTag: [numeric answers, ...]
        let keys = Object.keys(data[0]);
        let cleanNumericData = cleanTheData(keys, data)
        // Get the question text from the full data
        var sumtext = Object.keys(cleanNumericData).map(key => {
            let questionTextFull = data[0][key]

            let indOfSeperator = questionTextFull.indexOf(" - ")
            let questionText = questionTextFull.substring(0, indOfSeperator)
            let media = questionTextFull.slice(indOfSeperator + 3)
            let questionTag = key.substring(0, key.indexOf("_"))
            return {
                'key': key,
                value: {
                    questionText: questionText, media: media, questionTag: questionTag
                }
            }
        })
        var sumtextobj = sumtext.reduce(
            (obj, item) => Object.assign(obj, { [item.key]: item.value }), {});

        // Compute summary statistics
        // NOTE: uses both cleanNumericData AND original data to get, respectively, numerics and te
        var sumstat = Object.keys(cleanNumericData).map(key => {
            // For each question
            // Get the question text from the full data
            let textInfo = sumtextobj[key]

            // Compute the boxplot summary statistics
            let q1 = d3.quantile(cleanNumericData[key],.25)
            let median = d3.quantile(cleanNumericData[key],.5)
            let q3 = d3.quantile(cleanNumericData[key],.75)
            let interQuantileRange = q3 - q1
            let min = d3.max([q1 - 1.5 * interQuantileRange, d3.min(cleanNumericData[key])])
            let max = d3.min([q3 + 1.5 * interQuantileRange, d3.max(cleanNumericData[key])])
            let minOutliers = cleanNumericData[key].filter( d => d < min)
            let maxOutliers = cleanNumericData[key].filter( d => d > max)
            let outliers = minOutliers.concat(maxOutliers)
            let total = cleanNumericData[key].length

            return {
                'key' : key,
                value: { questionText: textInfo.questionText, media: textInfo.media, questionTag: textInfo.questionTag, q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max, outliers: outliers, total: total, points: cleanNumericData[key] }
            }
        })

        // Create the html boxplots
        displayBoxplots(sumstat, boxplots)
    })
     */

    function cleanTheData(keys, data, mediaFilter = null) {
        let  cleanData = {}
        keys.forEach(function(key) {
            if(key === "Q4")
                return;
            // filter by media num
            if(mediaFilter !== null) {
                let num = parseInt(key.slice(key.indexOf('_') + 1))
                if (num !== mediaFilter) return;
            }
            // clean the data
            cleanData[key] = data
                .map(d => { return d[key] })
                .slice(2) // Ignore text and import id
                .map(p => { return phraseToNumber(p) })
                .filter(n => { return n != null })
                .sort(d3.ascending)
        })
        return cleanData
    }

    function displayBoxplots(sumstat, boxplots) {
        console.log("herehereher")
        console.log(sumstat)
        // From sumstat: key, questionText, min, max, q1, q3, median, outliers, total
        // Define positions
        var y = height / 2
        var yBandwidth = height / 4;
        var xText = d3.scalePoint()
            .domain(["SA", "A", "LA", "LD", "D", "SD", "NoAd"])
            .range([0, width])
        var x = d3.scaleLinear()
            .domain([1, 7])
            .range([0, width])

        // Make boxplot container, margin, and scale for each question
        displayContainersMargin(sumstat, boxplots)

        // Show axis labels
        displayAxis(sumstat, boxplots, xText)

        // Show title
        displayTitle(sumstat, boxplots)

        // Show the range line
        displayRange(sumstat, boxplots, x, y, yBandwidth)

        // Show the rectangle for the q1, q3 box
        displayBox(sumstat, boxplots, x, y, yBandwidth)

        // Show the median line
        displayMedian(sumstat, boxplots, x, y, yBandwidth)

        // Show the outliers
        displayOutliers(sumstat, boxplots, x, y, yBandwidth)

        // Show the totals
        displayTotals(sumstat, boxplots)
    }
    function displayContainersMargin(sumstat, boxplots) {
        boxplots
            .selectAll("boxplot") // No boxplots
            .data(sumstat) // Link to boxplot data
            .enter() // Create empties linked with data
            .append("svg") // container svg
            .attr("id", function(d) { return d.key;})
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g") // margin
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")")
            .classed("margin", true)
    }
    function displayAxis(sumstat, boxplots, scale){
        boxplots
            .selectAll(".margin")
            .data(sumstat)
            .append("g") // bottom axis
            .attr("transform", "translate(0," + height + ")")
            .classed("bottomAxis", true)
            .call(d3.axisBottom(scale).ticks(7)) // TODO: dynamically set the axis labels
            .select(".domain").remove()
    }
    function displayTitle(sumstat, boxplots) {
        boxplots
            .selectAll(".margin")
            .data(sumstat)
            .append("text")
            .attr("x", 0)
            .attr("y", margin.top)
            .classed("title", true)
            .text(function (d) {
                return d.value.questionText
            })
            .call(wrap, width)
    }
    function displayRange(sumstat, boxplots, xScale, y, yBandwidth) {
        boxplots
            .selectAll(".margin")
            .data(sumstat)
            .append("line")
            .attr("x1", function (d) {
                return xScale(d.value.min)
            })
            .attr("x2", function (d) {
                return xScale(d.value.max)
            })
            .attr("y1", y + yBandwidth / 2)
            .attr("y2", y + yBandwidth / 2)
            .attr("stroke", "black")
            .style("width", 40)
            .classed("range", true)
    }
    function displayBox(sumstat, boxplots, xScale, y, yBandwidth) {
        boxplots
            .selectAll(".margin")
            .data(sumstat)
            .append("rect")
            .attr("x", function (d) {
                return xScale(d.value.q1)
            })
            .attr("width", function (d) {
                return (xScale(d.value.q3) - xScale(d.value.q1))
            })
            .attr("y", y)
            .attr("height", yBandwidth)
            .attr("stroke", "black")
            .style("fill", "#69b3a2")
            .style("opacity", 0.3)
            .classed("box", true)
    }
    function displayMedian(sumstat, boxplots, xScale, y, yBandwidth) {
        boxplots
            .selectAll(".margin")
            .data(sumstat)
            .append("line")
            .attr("y1", y)
            .attr("y2", y + yBandwidth)
            .attr("x1", function (d) {
                return (xScale(d.value.median))
            })
            .attr("x2", function (d) {
                return (xScale(d.value.median))
            })
            .attr("stroke", "black")
            .style("width", 80)
            .classed("median", true)
    }
    function displayOutliers(sumstat, boxplots, xScale, y, yBandwidth) {
        boxplots
            .selectAll(".margin")
            .data(sumstat)
            .append("g")
            .classed("outliers", true)
            .each(function (d) {
                d3.select(this).selectAll('circles')
                    .data(d.value.outliers)
                    .enter()
                    .append('circle')
                    .attr("cx", function (d) {
                        return xScale(d)
                    })
                    .attr("cy", y + yBandwidth / 2)
                    .attr("r", 3)
                    .attr("opacity", 0.2)
            })
    }
    function displayTotals(sumstat, boxplots) {
        boxplots
            .selectAll(".margin")
            .data(sumstat)
            .append("text")
            .classed("total", true)
            .text(function(d) { return "# Responses: " + (d.value.total) })
            .attr("x", 0)
            .attr("y", height + 35)
    }

    // https://stackoverflow.com/questions/24784302/wrapping-text-in-d3?lq=1
    function wrap(text, width) {
        text.each(function () {
            var text = d3.select(this),
                words = text.text().split(/\s+/).reverse(),
                word,
                line = [],
                lineNumber = 0,
                lineHeight = 1.1, // ems
                x = text.attr("x"),
                y = text.attr("y"),
                dy = 0, //parseFloat(text.attr("dy")),
                tspan = text.text(null)
                    .append("tspan")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("dy", dy + "em");
            // While there are words to check
            while (word = words.pop()) {
                line.push(word);
                tspan.text(line.join(" "));
                // If this word creates overflow
                if (tspan.node().getComputedTextLength() > width) {
                    // Remove the overflow word
                    line.pop();
                    // Set the real text
                    tspan.text(line.join(" "));
                    // Compute the real text length and center
                    let length = tspan.node().getComputedTextLength()
                    tspan.attr("dx", (width - length)/2)
                    // Prepare the next tspan for the rest of the words
                    line = [word];
                    tspan = text.append("tspan")
                        .attr("x", x)
                        .attr("y", y)
                        .attr("dy", ++lineNumber * lineHeight + dy + "em")
                        .text(word);
                }
            }
            // Compute the real text length and center for leftover
            let length = tspan.node().getComputedTextLength()
            tspan.attr("dx", (width - length)/2)
        });
    }

    function phraseToNumber(phrase) {
        switch (phrase) {
            case "Strongly agree":
            case "Very Frequently":
            case "10 minutes or Less":
            case "Video":
                return 1;
            case "Agree":
            case "Frequently":
            case "About 30 minutes":
            case "Image":
                return 2;
            case "Slightly agree":
            case "Occasionally":
            case "About an hour":
            case "Text":
                return 3;
            case "Slightly disagree":
            case "Rarely":
            case "More than an hour or multiple hours":
            case "No priority":
                return 4;
            case "Disagree":
            case "Very Rarely":
                return 5;
            case "Strongly disagree":
            case "Never":
                return 6;
            case "There are no advertisements":
                return 7;
            case "":
                return null;
            default:
                throw new Error("Phrase '" +phrase+"' not supported")
            /*
            Strongly disagree, Disagree, Slightly disagree, Slightly agree, Agree, Strongly agree
            Never, Very Rarely, Rarely, Occasionally, Frequently, Very Frequently
            There are no advertisements
            10 minutes or Less, About 30 minutes, About an hour, More than an hour or multiple hours
            Video, Image, Text, No Priority
             */
        }
    }
    function numberToMedia(number){
        switch(number){
            case 1:
                return "Twitter";
            case 2:
                return "Instagram";
            case 3:
                return "Reddit";
            case 4:
                return "Tumblr";
            case 5:
                return "Tik Tok";
            case 6:
                return "BeReal";
            case 7:
                return "YouTube";
            case 8:
                return "Snapchat";
            case 9:
                return "Facebook";
            case 10:
                return "4Chan";
            case 11:
                return "LinkedIn";
            case 12:
                return "Twitch";
            default:
                throw new Error("Media num '" +number+"' not supported")

        }
    }
    function mediaToNumber(media){

        switch(media) {
            case "Twitter":
                return 1;
            case "Instagram":
                return 2;
            case "Reddit":
                return 3;
            case "Tumblr":
                return 4;
            case "Tik Tok":
                return 5;
            case "BeReal":
                return 6;
            case "YouTube":
                return 7;
            case "Snapchat":
                return 8;
            case "Facebook":
                return 9;
            case "4Chan":
                return 10;
            case "LinkedIn":
                return 11;
            case "Twitch":
                return 12;
            default:
                throw new Error("Media '" +media+"' not supported")
        }
    }
    function questionToScale(question){
        switch (question){
            case "C1":
            case "C2":
            case "C3":
            case "C6":
            case "D1":
            case "D5":
            case "D6":
            case "D7":
            case "D8":
            case "A3":
            case "A4":
                return ["Very Frequently", "Frequently", "Occasionally", "Rarely", "Very Rarely", "Never" ]
            case "A2":
                return ["Strongly agree", "Agree", "Slightly agree", "Slightly disagree", "Disagree", "Strongly disagree", "There are no advertisements"]
            case "D3":
                return ["Video", "Image", "Text", "No Priority"]
            case "D2":
                return["10 minutes or Less", "About 30 minutes", "About an hour", "More than an hour or multiple hours"]
            default:
                return ["Strongly agree", "Agree", "Slightly agree", "Slightly disagree", "Disagree", "Strongly disagree"]
        }
    }
</script>
</body>
</html>
